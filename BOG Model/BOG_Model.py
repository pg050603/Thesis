"""
LH2 Carrier BOG Prediction (Continuous Venting & Geospatial Update)
Reads: LH2_Voyage_Geospatial.xlsx (Generated by Julia)
"""

import logging
import math
from dataclasses import dataclass
from typing import Optional, List
import numpy as np
import pandas as pd
import CoolProp.CoolProp as CP

# --- Configuration ---
FLUID_NAME = "ParaHydrogen"
# Setup logging
logging.basicConfig(level=logging.INFO, format="%(message)s")

@dataclass
class TankSpecs:
    volume_m3: float = 1250.0
    surface_area_m2: float = 560.0
    insulation_u_value: float = 0.009
    # The pressure setpoint (valve opening pressure)
    pressure_setpoint_pa: float = 1.3e5  # 1.3 bar abs (Operating pressure)
    mawp_pa: float = 5.0e5 

@dataclass
class SimulationConfig:
    initial_fill_ratio: float = 0.98
    time_step_hours: float = 1.0
    design_speed_knots: float = 15.0

class BOGSimulator:
    def __init__(self, tank: TankSpecs, voyage_df: pd.DataFrame, config: SimulationConfig):
        self.tank = tank
        self.voyage = voyage_df
        self.config = config
        self.results = []

    def _get_sloshing_factor(self, wave_height_m, speed, fill_ratio):
        # Improved correlation using actual Wave Height from Julia
        # Scale: 0m -> 1.0, 5m -> 1.5, 10m -> 2.0 (non-linear)
        wave_factor = 1.0 + 0.15 * (max(wave_height_m, 0)**1.3)
        
        # Speed factor
        speed_factor = (speed / 15.0) ** 0.5
        
        # Resonance at 30% and 70% fill (typical for membrane tanks)
        # Using a double-gaussian shape
        f = fill_ratio
        resonance = 0.2 * (np.exp(-((f-0.3)/0.1)**2) + np.exp(-((f-0.7)/0.1)**2))
        
        return max(1.0, (wave_factor * speed_factor) + resonance)

    def run(self):
        # 1. Initialize State (Saturated Liquid at Setpoint usually)
        # Assume we load saturated liquid at 1.1 bar
        P_current = 1.1e5 
        rho_liq = CP.PropsSI("D", "P", P_current, "Q", 0.0, FLUID_NAME)
        mass_current = self.tank.volume_m3 * self.config.initial_fill_ratio * rho_liq
        
        # Internal Energy (J/kg)
        u_current = CP.PropsSI("U", "P", P_current, "Q", 0.0, FLUID_NAME)
        U_total = u_current * mass_current # Total Joules in tank
        
        initial_mass = mass_current
        cumulative_bog = 0.0
        
        dt_s = self.config.time_step_hours * 3600.0

        print(f"{'Time(h)':<8} {'Lat':<8} {'Hs(m)':<6} {'P(bar)':<8} {'Q_in(W)':<10} {'BOG(kg/h)':<10}")
        print("-" * 65)

        for row in self.voyage.itertuples():
            # --- Inputs ---
            t_amb = row.Ambient_Temp_K
            wave_h = row.Sig_Wave_Height_m
            speed = row.Ship_Speed
            
            # --- 1. Current Fluid State ---
            # Derived from Mass and Total Energy
            rho_current = mass_current / self.tank.volume_m3
            u_specific = U_total / mass_current
            
            try:
                # Flash calculation to get T and P
                T_fluid = CP.PropsSI("T", "D", rho_current, "U", u_specific, FLUID_NAME)
                P_fluid = CP.PropsSI("P", "D", rho_current, "U", u_specific, FLUID_NAME)
            except:
                # Fallback if EOS fails near saturation
                P_fluid = P_current
                T_fluid = CP.PropsSI("T", "P", P_fluid, "Q", 0.0, FLUID_NAME)

            # --- 2. Heat Transfer ---
            # A. Static Heat Leak (UA * dT)
            q_static = self.tank.insulation_u_value * self.tank.surface_area_m2 * (t_amb - T_fluid)
            
            # B. Sloshing Multiplier
            ssf = self._get_sloshing_factor(wave_h, speed, mass_current/initial_mass)
            q_total = q_static * ssf

            # --- 3. Energy Balance & Venting Logic ---
            
            # Add Heat to Total Energy
            energy_input = q_total * dt_s
            U_trial = U_total + energy_input
            
            # Check Trial Pressure
            u_trial_spec = U_trial / mass_current
            P_trial = CP.PropsSI("P", "D", rho_current, "U", u_trial_spec, FLUID_NAME)
            
            bog_kg = 0.0
            mode = "Holding"

            # --- CONTINUOUS VENTING LOGIC ---
            # If P is above setpoint, we vent immediately to hold P constant.
            # BOG mass is derived from Latent Heat of Vaporization (h_fg).
            # BOG rate = Q_total / h_fg
            
            if P_trial >= self.tank.pressure_setpoint_pa:
                mode = "Venting"
                
                # Enthalpy of Vaporization at Setpoint Pressure
                h_gas = CP.PropsSI("H", "P", self.tank.pressure_setpoint_pa, "Q", 1.0, FLUID_NAME)
                h_liq = CP.PropsSI("H", "P", self.tank.pressure_setpoint_pa, "Q", 0.0, FLUID_NAME)
                h_fg = h_gas - h_liq # Latent heat (J/kg)
                
                # Mass to vent to neutralize the heat input
                # m_boil = Q_total [J/s] / h_fg [J/kg] * time [s]
                bog_kg = (q_total / h_fg) * dt_s
                
                # Update System Mass and Energy
                # We remove the mass, and we remove the Enthalpy of the vapor leaving
                mass_current -= bog_kg
                U_total = U_trial - (bog_kg * h_gas)
                
                # Reset Pressure to Setpoint (as we vented the excess)
                P_current = self.tank.pressure_setpoint_pa
            else:
                # Pressure accumulation (Sub-cooled or pressurizing phase)
                U_total = U_trial
                P_current = P_trial

            cumulative_bog += bog_kg

            # Record
            self.results.append({
                "Time_hr": row.Time_hr,
                "Lat": row.Latitude,
                "Wave_Height_m": wave_h,
                "Pressure_bar": P_current/1e5,
                "Temperature_K": T_fluid,
                "Heat_Leak_W": q_total,
                "BOG_kg_step": bog_kg,
                "Cum_BOG_kg": cumulative_bog
            })
            
            # Print sample every 24 hours
            if row.Index % 24 == 0:
                 print(f"{row.Time_hr:<8.1f} {row.Latitude:<8.1f} {wave_h:<6.2f} {P_current/1e5:<8.4f} {q_total:<10.1f} {bog_kg:<10.3f}")

        return pd.DataFrame(self.results)

# --- Run ---
if __name__ == "__main__":
    # Load Julia Data
    try:
        df_geo = pd.read_excel("LH2_Voyage_Geospatial.xlsx")
        
        sim = BOGSimulator(TankSpecs(), df_geo, SimulationConfig())
        res = sim.run()
        
        res.to_excel("LH2_Final_Results_Continuous.xlsx", index=False)
        print("\nDone. Results saved to LH2_Final_Results_Continuous.xlsx")
        
    except FileNotFoundError:
        print("Error: Run the Julia script first to generate 'LH2_Voyage_Geospatial.xlsx'")